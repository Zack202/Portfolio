/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: drei.lu (https://sketchfab.com/drei.lu)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/space-exploration-wlp-series-8-91964c1ce1a34c3985b6257441efa500
Title: Space exploration [WLP series #8]
*/

import * as THREE from 'three';
import React, { useRef, useEffect } from 'react';
import { useGLTF } from '@react-three/drei';
import { useFrame, useThree } from '@react-three/fiber';
import { GLTF } from 'three-stdlib';
import { a } from '@react-spring/three';
import { Vector3, Euler } from 'three';

import planetScene from '../3d/space_exploration_wlp_series_8.glb';

type GLTFResult = GLTF & {
  nodes: {
    planet001_1: THREE.Mesh;
    planet001_2: THREE.Mesh;
  };
  materials: {
    scene: THREE.MeshStandardMaterial;
  };
};


const Planet = (
  { isRotating, setIsRotating, position, scale, rotation, setCurrentStage }:
  { isRotating: boolean,
    setIsRotating: React.Dispatch<React.SetStateAction<boolean>>,
    position: Vector3,
    scale: Vector3,
    rotation: Euler,
    setCurrentStage: React.Dispatch<React.SetStateAction<number>> }) => {
  const planetRef = useRef<THREE.Group>(null);

  const { gl, viewport } = useThree();
  const { nodes, materials } = useGLTF(planetScene) as GLTFResult;

  const lastX = useRef(0);
  const lastY = useRef(0);
  const rotationSpeedX = useRef(0); // Separate rotation speed for X
  const rotationSpeedY = useRef(0); // Separate rotation speed for Y
  const dampingFactor = 0.95;
  const initialRotation = useRef(rotation.clone()); // Store the initial rotation

  const handlePointerDown = (event: PointerEvent | TouchEvent) => {
    event.stopPropagation();
    event.preventDefault();
    setIsRotating(true);

    const clientX = 'touches' in event ? event.touches[0].clientX : event.clientX;
    const clientY = 'touches' in event ? event.touches[0].clientY : event.clientY;
    lastX.current = clientX;
    lastY.current = clientY;
  };

  const handlePointerUp = (event: PointerEvent | TouchEvent) => {
    event.stopPropagation();
    event.preventDefault();
    setIsRotating(false);
  };

  const handlePointerMove = (event: PointerEvent | TouchEvent) => {
    event.stopPropagation();
    event.preventDefault();

    if (isRotating) {
      const clientX = 'touches' in event ? event.touches[0].clientX : event.clientX;
      const clientY = 'touches' in event ? event.touches[0].clientY : event.clientY;
      const deltaX = (clientX - lastX.current) / viewport.width;
      const deltaY = (clientY - lastY.current) / viewport.height;

      if (planetRef.current) {
        planetRef.current.rotation.y += deltaX  * 0.05 * Math.PI;
        planetRef.current.rotation.x += deltaY * 0.05 * Math.PI;
      }

      lastX.current = clientX;
      lastY.current = clientY;
      rotationSpeedX.current = deltaX * 0.05 * Math.PI; // Calculate rotation speed for X
      rotationSpeedY.current = deltaY * 0.05 * Math.PI; // Calculate rotation speed for Y
    }
  };

  const handleKeyDown = (event: KeyboardEvent) => {
    if (event.key === 'ArrowRight') {
      if (!isRotating) setIsRotating(true);
      if (planetRef.current) {
        planetRef.current.rotation.y -= 0.01 * Math.PI;
      }
      rotationSpeedY.current = -0.01 * Math.PI;
    } else if (event.key === 'ArrowLeft') {
      if (!isRotating) setIsRotating(true);
      if (planetRef.current) {
        planetRef.current.rotation.y += 0.01 * Math.PI;
      }
      rotationSpeedY.current = 0.01 * Math.PI;
    } else if (event.key === 'ArrowUp') {
      if (!isRotating) setIsRotating(true);
      if (planetRef.current) {
        planetRef.current.rotation.x -= 0.01 * Math.PI;
      }
      rotationSpeedX.current = -0.01 * Math.PI;
    } else if (event.key === 'ArrowDown') {
      if (!isRotating) setIsRotating(true);
      if (planetRef.current) {
        planetRef.current.rotation.x += 0.01 * Math.PI;
      }
      rotationSpeedX.current = 0.01 * Math.PI;
    }
  };

  const handleKeyUp = (event: KeyboardEvent) => {
    if (event.key === 'ArrowRight' || event.key === 'ArrowLeft' || event.key === 'ArrowUp' || event.key === 'ArrowDown') {
      setIsRotating(false);
    }
  };

  // This function is called on each frame update
  useFrame(() => {
    // If not rotating, apply damping to slow down the rotation (smoothly)
    if (!isRotating) {
      // Apply damping factor
      rotationSpeedX.current *= dampingFactor;
      rotationSpeedY.current *= dampingFactor;

      // Stop rotation when speed is very small
      if (Math.abs(rotationSpeedX.current) < 0.001) {
        rotationSpeedX.current = 0;
      }
      if (Math.abs(rotationSpeedY.current) < 0.001) {
        rotationSpeedY.current = 0;
      }

      if (planetRef.current) {
        planetRef.current.rotation.y += rotationSpeedX.current; // Apply rotation speed for Y
        planetRef.current.rotation.x += rotationSpeedY.current; // Apply rotation speed for X
      }

      if (!planetRef.current) return;
      const normalizedRotationX =
      ((planetRef.current.rotation.x % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
      const normalizedRotationY =
      ((planetRef.current.rotation.y % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
      if (normalizedRotationX < 0.1) {
        planetRef.current.rotation.x = 0;
      }
      // Set the current stage based on the planet's orientation
      switch (true) {
      case normalizedRotationY >= 5.45 && normalizedRotationY <= 5.85:
        setCurrentStage(4);
        break;
      case normalizedRotationY >= 0.85 && normalizedRotationY <= 1.3:
        setCurrentStage(3);
        break;
      case normalizedRotationY >= 2.4 && normalizedRotationY <= 2.6:
        setCurrentStage(2);
        break;
      case normalizedRotationY >= 4.25 && normalizedRotationY <= 4.75:
        setCurrentStage(1);
        break;
      default:
        setCurrentStage(0);
      }
    }
  });

  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointermove', handlePointerMove);
    canvas.addEventListener('pointerup', handlePointerUp);
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown);
      canvas.removeEventListener('pointermove', handlePointerMove);
      canvas.removeEventListener('pointerup', handlePointerUp);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [gl, handlePointerDown, handlePointerMove, handlePointerUp, handleKeyDown, handleKeyUp]);

  return (
    <a.group ref={planetRef} position={position} scale={scale} rotation={initialRotation.current} >
      <group rotation={[-Math.PI / 2, 0, 0]}>
        <group position={[-0.00329, 0.02369, -6.33114]} rotation={[0.23801904, -0.54538751, 0.56227659]} scale={[7.0000021, 6.99999781, 6.9999993]}>
          <mesh geometry={nodes.planet001_1.geometry} material={materials.scene} />
          <mesh geometry={nodes.planet001_2.geometry} material={materials.scene} />
        </group>
      </group>
    </a.group>
  );
};

export default Planet;